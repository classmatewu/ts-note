1. ts是js的超集。
   怎么理解这句话呢？首先超集是扩展的意思，即在向前兼容的同时，对语法进行进一步的扩展，例如es6是es5的超集。
   ts是在兼容es语法的同时，做了一些扩展，例如类型约束、**静态类型**、面向对象等语法思想。
   即：ts > es6+ > es5

2. 静态类型有什么优点？
   跟java等语言一样，ts是一门静态类型语言，那么何为静态类型语言呢？顾名思义，静态类型，相比动态类型而言，
   类型是静态等，也就是一旦确定了就不能改变，这样有几点好处：
   * 在编辑器支持ts编译的前提下，可以在代码编译时将一些类型**提前错误抛出来**，而不必等到代码运行时再发现错误。
     尽早发现问题，提高开发效率。
   * 由于提前定义好变量（基本/引用）的类型，这就给代码程序提供了良好的**语义化**，增强了代码的**可读性**
   * 由于提前定义好变量（基本/引用）的类型，包括它的**类型原型链上的属性/方法**、**定义的模具（引用类型）**，即包含什么属性/方法，以及分别是什么类型的，这就使得支持
     ts编译的编辑器能够有更好的**代码提示**
   * 此外，静态类型让代码更加的**严谨**，而不是类型随意改动

3. java与js语言有几大区别：
   * 静态类型和动态类型：通过ts对js的扩展，使得js也变得静态化，提高了一定的开发效率和代码的严谨性
   * 面向对象的支持度：js由于本身语言的设计问题，对面向对象的编程思想支持不够，ts对js的扩展，也解决了这点，
     ts提供了更多的面向对象编程思想的语法扩展
   * 编译型语言与解释型语言：这是语言本身的设计角度问题。
    - 编译型语言是将代码编译为机器码，然后在各个平台上跑。
      例如java的**编译器——JVM**将java代码先编译为字节码，再编译为机器码。但由于OS + CPU指令集的不同，所以在各个平台的
      机器码其实是不一样的，这就使得java这种静态语言得分别编译对应的机器码，才能达到跨平台运行的效果。
      所以编译型语言跨平台性低，但执行效率高，因为直接就是机器码了
    - 解释型语言是不直接编译成机器码，而生源码打包压缩混淆后，直接在对应平台上跑，由于对应平台不认识高级语言，只认识机器语言，
      所以就语言一个**解释器**，例如知名的js解释器——v8引擎。解释器的作用是边编译，边执行，这就使得效率会稍微低一点点（后来
      引入及时编译JOT，会有大幅度改善），但是跨平台性好，只要有浏览器（v8引擎解释器），就能运行js代码

4. 如何运行ts文件代码？
   ts是js的扩展，所以还是一门解释型语言，所以还得依赖解释器才能运行
   * tsc：适合浏览器或者node环境。
     由于v8引擎不支持ts语言的解释运行，所以不能在浏览器下直接运行ts代码，而需要先编译js代码。
     所以ts只是在编译时起作用，我们可以看到编译后的js代码，没有ts的那些扩展——类型约束等扩展语法。
     甚至ts编译报错，你都可以直接不理，也丝毫不影响我们js逻辑代码的运行，只是ts编译成js层面的报错，
     可能是某些语法不严谨，但整个程序还是可以跑起来的。
     ```
     // 安装 tsc —— typescript complier
     yarn global add typesscript
     // 编译ts成js
     tsc test.ts
     // 运行编译后的js代码
     node test.js
     或
     复制js代码到浏览器控制台运行
     ```
  * ts-node：适合node环境
    ```
    // 安装ts-node
    yarn add global ts-node
    // 直接运行ts代码，包含了ts的编译过程
    ts-node test.ts
    ```

5. 如何初始化一个ts项目，在项目根路径下执行：
   ```
   tsc --init
   ```
   类似`npm init -y`，执行完之后就会出现一个`tsconfig.json`，便可以在里面写一些本项目的ts配置

6. 若执行`tsc`命令且默认不带任何参数的话，`tsc`命令就会按照`tsconfig.json`来进行执行。
   例如可以指定以下参数等配置：
   * include: tsc要编译哪些，默认是当前路径下所有.ts
   * exclude: tsc不编译哪些文件
   * removeComments: 干掉注释
   * NoImpliciAny: 不能隐式申明any，若要定义any类型，也一定要显示地写出来
   * strictNullChecks: 不能赋值null
   * rootDir: 指定编译入口文件夹
   * baseUrl: 要编译的文件的相对当前路径
   * outDir: 指定出口文件夹
   * outFile: 如果有这个值的话，会把所有的ts文件编译并放在一个单一文件中，而不是一个ts对应一个js文件
              但注意此时的module值不能有comonjs，可以试试amd模块，但是浏览器不认识这种define的amd模块，必须提供这样的runtime代码，类似webpack一样，或者直接引入requirejs/seajs这类工具，给浏览器注入这些runtime方法
   * sourceMap: 是否开启sourceMap功能
   * noUnusedxxx: 是否检查定义了但为使用的变量/方法
   * target: 编译后的目标代码的es版本，例如es5
   * allowJs: 是否编译js文件，因为ts是含有类型约束的js超集，对于js文件我们可以例如将es6编译为es5
   * checkJs: 是否检查js文件的语法错误，例如`const a = 1; console.log(a.b.c)`，这个时候会编辑器会对a.b.c报错提示
   * strict: 开启严格模式，默认一些配置参数后为true
   看了tsconfig.json配置文件后，更能理解ts是js的超集这个概念了，或者可以说tsc是babel的超集

7. tsc命令后不带任何参数，就会去找tsconfig.json配置，而ts-node命令不管后面有没有参数，都会默认去根据tsconfig.json配置来

8. `tsc -w`可以处于watch模式，不用每次都去重新启动tsc进行编译，类型webpack-dev-server的watch模式
